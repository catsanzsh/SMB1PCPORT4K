import asyncio
import platform
import pygame
import random  # We'll use a deterministic variant for level generation

# Initialize Pygame, let's get this adventure started!
pygame.init()

# Constants for our Mario world
WIDTH, HEIGHT = 256, 240  # NES resolution for that classic feel!
SCALE = 2
SCREEN_WIDTH, SCREEN_HEIGHT = WIDTH * SCALE, HEIGHT * SCALE
FPS = 60
TILE_SIZE = 16
LEVEL_HEIGHT_TILES = 15
MAX_LEVEL_WIDTH_TILES = 300  # The level has an end, hooray!
GENERATION_SEED = 69420  # A fun seed for consistent level generation!

# Colors to make our world vibrant!
BLACK = (0, 0, 0)
RED = (255, 0, 0)       # Mario's classic outfit
BLUE = (0, 0, 255)      # Ground and platforms
BROWN = (139, 69, 19)   # Goomba
YELLOW = (255, 255, 0)  # Question block
GREEN = (0, 255, 0)     # Pipe
GRAY = (128, 128, 128)  # Empty/Hit block
WHITE = (255, 255, 255)
PINK_MUSHROOM = (255, 150, 150)  # For our adorable mushrooms!
BRICK_COLOR = (205, 133, 63)  # A warm brown for brick blocks

# Tile types for our procedurally generated world
# 0: Empty (air)
# 1: Solid (Ground/Platform)
# 2: Empty/Hit Block (still solid)
# 3: Question Block (active, solid, spawns items!)
# 4: Pipe (solid)
# 5: Brick Block (breakable by Super Mario!)
TILE_COLORS = {
    0: BLACK,
    1: BLUE,
    2: GRAY,
    3: YELLOW,
    4: GREEN,
    5: BRICK_COLOR,
}

# Mario's states
MARIO_SMALL = 0
MARIO_SUPER = 1
# MARIO_FIRE = 2  # For future fiery adventures!

# Power-up types
ITEM_MUSHROOM = 0
# ITEM_FIREFLOWER = 1  # More power-ups to come!

# Set up the display for our Mushroom Kingdom adventure!
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Super Mario Bros. - Generated by SuperStar Engine!")
clock = pygame.time.Clock()
font = pygame.font.Font(None, 36)  # For scores and text

# ---- Mario Class: Our Brave Hero! ----
class Mario:
    def __init__(self, x, y):
        self.x = float(x)
        self.y = float(y)
        self.width = TILE_SIZE
        self.base_height = TILE_SIZE  # Small Mario's height
        self.height = self.base_height
        self.vel_x = 0.0
        self.vel_y = 0.0
        self.on_ground = True
        self.state = MARIO_SMALL
        self.jump_strength = -10.5  # A super jump!
        self.acceleration = 0.25  # Smooth movement
        self.max_speed = 2.8  # Zoom!
        self.friction = 0.88  # Slows down when not moving
        self.grace_jump_timer = 0  # A little extra jump time
        self.rect = pygame.Rect(self.x, self.y, self.width, self.height)
        self.update_size_and_rect()  # Set up size properly

    def update_size_and_rect(self):
        if self.state == MARIO_SUPER:
            self.height = self.base_height * 2
        else:
            self.height = self.base_height
        self.rect.topleft = (self.x, self.y)
        self.rect.size = (self.width, self.height)

    def draw(self, camera_x_offset):
        self.update_size_and_rect()  # Keep the rect updated
        screen_mario_x = (self.x - camera_x_offset) * SCALE
        screen_mario_y = self.y * SCALE
        
        body_color = RED
        
        if self.state == MARIO_SMALL:
            pygame.draw.rect(screen, body_color, (screen_mario_x, screen_mario_y, self.width * SCALE, self.height * SCALE))
        elif self.state == MARIO_SUPER:
            # Super Mario is taller!
            pygame.draw.rect(screen, body_color, (screen_mario_x, screen_mario_y, self.width * SCALE, (self.base_height) * SCALE))  # Top part
            pygame.draw.rect(screen, (200, 0, 0), (screen_mario_x, screen_mario_y + (self.base_height) * SCALE, self.width * SCALE, (self.base_height) * SCALE))  # Bottom part

    def jump(self):
        if self.on_ground or self.grace_jump_timer > 0:  # Jump just after leaving a platform!
            self.vel_y = self.jump_strength
            self.on_ground = False
            self.grace_jump_timer = 0  # Used the extra jump time
            # print("Boing! Mario jumped!")

    def grow(self):
        if self.state == MARIO_SMALL:
            self.state = MARIO_SUPER
            self.y -= self.base_height  # Move Mario up so his feet stay in place
            self.update_size_and_rect()
            print("Wow! Mario powered up to Super Mario!")
            return True  # Growth successful
        return False  # Already super

    def shrink_or_die(self):
        if self.state == MARIO_SUPER:
            self.state = MARIO_SMALL
            self.y += self.base_height  # Move Mario down
            self.update_size_and_rect()
            print("Ouch! Mario shrunk back to small size!")
            return False  # Mario's still in the game
        else:
            print("Oh no! Mario lost a life!")
            return True  # Mario's out of luck

    def handle_input(self):
        keys = pygame.key.get_pressed()
        
        target_vel_x_influence = 0
        if keys[pygame.K_LEFT]:
            target_vel_x_influence = -1
        if keys[pygame.K_RIGHT]:
            target_vel_x_influence = 1
        
        if target_vel_x_influence != 0:
            self.vel_x += target_vel_x_influence * self.acceleration
            self.vel_x = pygame.math.clamp(self.vel_x, -self.max_speed, self.max_speed)
        else:
            self.vel_x *= self.friction
            if abs(self.vel_x) < 0.05:
                self.vel_x = 0

        if keys[pygame.K_SPACE]:
            self.jump()  # Jump away!

    def update_physics_and_collision(self, get_tile_func, modified_tiles_ref, active_powerups_ref, active_enemies_ref):
        global score  # Let's keep track of those points!

        # Horizontal movement and collision
        self.x += self.vel_x
        self.update_size_and_rect()
        
        colliding_tiles_horz = get_overlapping_solid_tiles(self.rect, get_tile_func)
        for tile_r, tx, ty, tile_id in colliding_tiles_horz:
            if self.vel_x > 0:  # Moving right, hit a wall
                self.x = tile_r.left - self.width
                self.vel_x = 0
            elif self.vel_x < 0:  # Moving left, bumped into something
                self.x = tile_r.right
                self.vel_x = 0
            self.rect.x = self.x
            break
        
        # Vertical movement and collision
        if not self.on_ground:
            self.vel_y += gravity
        
        self.y += self.vel_y
        self.update_size_and_rect()

        on_ground_this_frame = False
        colliding_tiles_vert = get_overlapping_solid_tiles(self.rect, get_tile_func)

        for tile_r, tx, ty, tile_id in colliding_tiles_vert:
            if self.vel_y > 0:  # Landing on something
                self.y = tile_r.top - self.height
                self.vel_y = 0
                on_ground_this_frame = True
            elif self.vel_y < 0:  # Hit a block from below
                self.y = tile_r.bottom
                self.vel_y = 0
                
                original_tile_type_in_level = get_tile_func(tx, ty, query_modified=False)
                if (tx, ty) not in modified_tiles_ref or modified_tiles_ref[(tx, ty)] != TILE_COLORS[2]:
                    if original_tile_type_in_level == 3:  # Question Block hit!
                        modified_tiles_ref[(tx, ty)] = 2  # Change to empty block
                        score += 100
                        if self.state == MARIO_SMALL:
                            new_item = PowerUpItem(tx * TILE_SIZE, ty * TILE_SIZE + TILE_SIZE, ITEM_MUSHROOM)
                            active_powerups_ref.append(new_item)
                            print(f"Yay! Hit a Question Block at ({tx},{ty})! A mushroom appeared!")
                        else:
                            print(f"Nice! Hit a Question Block at ({tx},{ty})! Super Mario says hi!")
                    elif original_tile_type_in_level == 5:  # Brick Block hit!
                        if self.state == MARIO_SUPER:
                            modified_tiles_ref[(tx, ty)] = 0  # Break the brick!
                            score += 50
                            print("Boom! Super Mario smashed a brick block!")
                        else:
                            print("Bump! Small Mario can't break that brick!")
            self.rect.y = self.y
            break
        
        self.on_ground = on_ground_this_frame
        if self.on_ground:
            self.grace_jump_timer = 5
        else:
            if self.grace_jump_timer > 0:
                self.grace_jump_timer -= 1
        
        self.x = max(0, min(self.x, MAX_LEVEL_WIDTH_TILES * TILE_SIZE - self.width))
        self.update_size_and_rect()

# ---- PowerUpItem Class: Mushrooms and More! ----
class PowerUpItem:
    def __init__(self, x, y, item_type=ITEM_MUSHROOM):
        self.x = float(x)
        self.y = float(y)
        self.width = TILE_SIZE
        self.height = TILE_SIZE
        self.vel_x = 1.2  # Mushrooms move steadily
        self.vel_y = 0.0
        self.on_ground = False
        self.item_type = item_type
        self.is_emerging = True
        self.emerge_target_y = y - TILE_SIZE
        self.rect = pygame.Rect(self.x, self.y, self.width, self.height)

    def update(self, get_tile_func):
        if self.is_emerging:
            self.y -= 0.7  # Rise from the block
            if self.y <= self.emerge_target_y:
                self.y = self.emerge_target_y
                self.is_emerging = False
                # print("Mushroom popped out! Ready to roll!")
            self.rect.topleft = (self.x, self.y)
            return

        self.x += self.vel_x
        self.vel_y += gravity
        self.y += self.vel_y
        self.rect.topleft = (self.x, self.y)

        on_ground_this_frame = False
        colliding_tiles_vert = get_overlapping_solid_tiles(self.rect, get_tile_func)
        for tile_r, _, _, _ in colliding_tiles_vert:
            if self.vel_y > 0:
                self.y = tile_r.top - self.height
                self.vel_y = 0
                on_ground_this_frame = True
            elif self.vel_y < 0:
                self.y = tile_r.bottom
                self.vel_y = 0
            self.rect.y = self.y
            break
        self.on_ground = on_ground_this_frame
        
        temp_horz_rect = pygame.Rect(self.x, self.y - self.vel_y, self.width, self.height)
        colliding_tiles_horz = get_overlapping_solid_tiles(temp_horz_rect, get_tile_func)
        wall_hit = False
        for tile_r, _, _, _ in colliding_tiles_horz:
            if self.vel_x > 0:
                self.x = tile_r.left - self.width
            elif self.vel_x < 0:
                self.x = tile_r.right
            self.vel_x *= -1
            wall_hit = True
            self.rect.x = self.x
            break
        
        if self.on_ground and not wall_hit:
            probe_x = self.x + (self.width if self.vel_x > 0 else -1)
            probe_y = self.y + self.height + (TILE_SIZE / 2)
            check_tx = int(probe_x // TILE_SIZE)
            check_ty = int(probe_y // TILE_SIZE)
            if get_tile_func(check_tx, check_ty) == 0:
                self.vel_x *= -1
        
        self.rect.topleft = (self.x, self.y)

    def draw(self, camera_x_offset):
        screen_x = (self.x - camera_x_offset) * SCALE
        if screen_x + self.width * SCALE > 0 and screen_x < SCREEN_WIDTH:
            color = PINK_MUSHROOM
            if self.item_type == ITEM_MUSHROOM:
                cap_height = self.height * 0.6
                stem_height = self.height * 0.4
                stem_width = self.width * 0.5
                stem_offset_x = (self.width - stem_width) / 2
                pygame.draw.rect(screen, color, (screen_x, self.y * SCALE, self.width * SCALE, cap_height * SCALE))
                pygame.draw.rect(screen, (230, 230, 230), (screen_x + stem_offset_x * SCALE, (self.y + cap_height) * SCALE, stem_width * SCALE, stem_height * SCALE))

# ---- Game Variables for Our Adventure! ----
mario_player = Mario(50.0, (LEVEL_HEIGHT_TILES - 3) * TILE_SIZE)  # Our hero starts here!
gravity = 0.55  # Keeps things grounded
camera_x = 0.0
score = 0
active_powerups = []  # Holds mushrooms and future items
enemies = []  # Goombas and other challenges
modified_tiles = {}  # Tracks changes like hit blocks

# ---- Procedural Generation Logic by SuperStar Engine ----
def deterministic_random_int(x, y, seed_offset=0, max_val=0x7FFFFFFF):
    # A consistent way to generate random-like numbers for the same spot
    h = GENERATION_SEED + seed_offset
    h = (h * 31 + x) & 0xFFFFFFFF
    h = (h * 31 + y) & 0xFFFFFFFF
    h = (h ^ (h >> 15)) * 2654435761 & 0xFFFFFFFF
    h = (h ^ (h >> 13)) * 2654435761 & 0xFFFFFFFF
    h = (h ^ (h >> 16)) & 0xFFFFFFFF
    return h % (max_val + 1)

def get_tile_type(tx, ty, query_modified=True):
    if query_modified and (tx, ty) in modified_tiles:
        return modified_tiles[(tx, ty)]

    if tx < 0 or ty < 0 or ty >= LEVEL_HEIGHT_TILES or tx >= MAX_LEVEL_WIDTH_TILES:
        if ty == LEVEL_HEIGHT_TILES and 0 <= tx < MAX_LEVEL_WIDTH_TILES:
            return 1  # Invisible floor
        return 0  # Outside the map

    # Ground layer
    if ty >= LEVEL_HEIGHT_TILES - 2:
        if (tx % 25 >= 15) and (tx % 25 < 19):
            if tx < 5:
                return 1  # No pit at the start
            return 0  # A pit!
        return 1  # Solid ground

    # Lower platforms
    if ty == LEVEL_HEIGHT_TILES - 5:
        if (tx % 12 < 5) and deterministic_random_int(tx // 12, ty, seed_offset=1, max_val=10) > 2:
            rand_block_type = deterministic_random_int(tx, ty, seed_offset=2, max_val=10)
            if rand_block_type > 7:
                if get_tile_type(tx, ty + 1, query_modified=False) == 0:
                    return 3  # Question Block
            elif rand_block_type > 4:
                if get_tile_type(tx, ty + 1, query_modified=False) == 0:
                    return 5  # Brick Block
            return 1  # Platform

    # Higher platforms
    if ty == LEVEL_HEIGHT_TILES - 8:
        if (tx % 18 < 7) and deterministic_random_int(tx // 18, ty, seed_offset=3, max_val=10) > 4:
            rand_block_type = deterministic_random_int(tx, ty, seed_offset=4, max_val=10)
            if rand_block_type > 8:
                if get_tile_type(tx, ty + 1, query_modified=False) == 0:
                    return 3  # Question Block
            elif rand_block_type > 6:
                if get_tile_type(tx, ty + 1, query_modified=False) == 0:
                    return 5  # Brick Block
            return 1  # Platform

    # Pipes
    if ty >= LEVEL_HEIGHT_TILES - 4 and ty < LEVEL_HEIGHT_TILES - 2:
        is_ground_below = all(get_tile_type(tx, check_y_ground, query_modified=False) != 0 for check_y_ground in range(LEVEL_HEIGHT_TILES - 2, LEVEL_HEIGHT_TILES))
        if is_ground_below:
            if (tx % 30 == 10 or tx % 30 == 11) and deterministic_random_int(tx // 30, LEVEL_HEIGHT_TILES - 1, seed_offset=5, max_val=10) > 6:
                if get_tile_type(tx, ty - 1, query_modified=False) == 0 and get_tile_type(tx, ty - 2, query_modified=False) == 0:
                    return 4  # Pipe

    # Random single blocks
    if ty < LEVEL_HEIGHT_TILES - 2:
        if deterministic_random_int(tx // 7, ty // 3, seed_offset=6, max_val=100) > 97:
            if get_tile_type(tx, ty + 1, query_modified=False) == 0:
                if deterministic_random_int(tx, ty, seed_offset=7, max_val=10) > 7:
                    return 3
                return 1
    return 0

# ---- Enemy Class: Goombas! ----
class Goomba:
    def __init__(self, x, y):
        self.x = float(x)
        self.y = float(y)
        self.width = TILE_SIZE
        self.height = TILE_SIZE
        self.vel_x = -0.5  # Goombas stroll along
        self.vel_y = 0.0
        self.on_ground = False
        self.rect = pygame.Rect(self.x, self.y, self.width, self.height)

    def update(self):
        self.x += self.vel_x
        self.vel_y += gravity
        potential_y = self.y + self.vel_y
        new_rect_y = pygame.Rect(self.x, potential_y, self.width, self.height)
        self.on_ground = False
        
        vert_coll_rects = get_overlapping_solid_tiles(new_rect_y, get_tile_type)
        for tile_r, _, _, _ in vert_coll_rects:
            if self.vel_y > 0:
                potential_y = tile_r.top - self.height
                self.vel_y = 0
                self.on_ground = True
            break
        self.y = potential_y

        if self.on_ground:
            next_x_tile_edge = int((self.x + (self.width if self.vel_x > 0 else -1)) // TILE_SIZE)
            current_ground_y_tile = int((self.y + self.height + 1) // TILE_SIZE)
            body_check_y_tile = int((self.y + self.height / 2) // TILE_SIZE)
            if get_tile_type(next_x_tile_edge, current_ground_y_tile) == 0 or \
               get_tile_type(next_x_tile_edge, body_check_y_tile) in [1, 2, 3, 4, 5]:
                self.vel_x *= -1
                if get_tile_type(next_x_tile_edge, body_check_y_tile) != 0:
                    if self.vel_x > 0:
                        self.x = next_x_tile_edge * TILE_SIZE - self.width - 0.1
                    else:
                        self.x = (next_x_tile_edge + 1) * TILE_SIZE + 0.1
        self.rect.topleft = (self.x, self.y)

    def draw(self, camera_x_offset):
        screen_x = (self.x - camera_x_offset) * SCALE
        if screen_x + self.width * SCALE > 0 and screen_x < SCREEN_WIDTH:
            pygame.draw.rect(screen, BROWN, (screen_x, self.y * SCALE, self.width * SCALE, self.height * SCALE))

# Enemy spawning
last_enemy_spawn_x_segment = -1
ENEMY_SPAWN_CHUNK_SIZE = WIDTH

def spawn_enemies_procedurally():
    global last_enemy_spawn_x_segment, enemies
    current_segment_coord = camera_x + SCREEN_WIDTH
    current_segment_idx = int(current_segment_coord / ENEMY_SPAWN_CHUNK_SIZE)

    if current_segment_idx > last_enemy_spawn_x_segment:
        last_enemy_spawn_x_segment = current_segment_idx
        spawn_x_start_tile = int((current_segment_idx * ENEMY_SPAWN_CHUNK_SIZE) / TILE_SIZE)
        spawn_x_end_tile = int(((current_segment_idx + 1) * ENEMY_SPAWN_CHUNK_SIZE) / TILE_SIZE)
        
        for tx in range(spawn_x_start_tile, min(spawn_x_end_tile, MAX_LEVEL_WIDTH_TILES)):
            if deterministic_random_int(tx, 0, seed_offset=100, max_val=100) > 93:
                for ty_candidate in range(LEVEL_HEIGHT_TILES - 3, LEVEL_HEIGHT_TILES - 9, -1):
                    if get_tile_type(tx, ty_candidate) == 0 and \
                       get_tile_type(tx, ty_candidate + 1) in [1, 4, 5]:
                        too_close = any(abs(existing_enemy.x - (tx * TILE_SIZE)) < TILE_SIZE * 4 for existing_enemy in enemies)
                        if not too_close:
                            enemies.append(Goomba(tx * TILE_SIZE, ty_candidate * TILE_SIZE))
                            break

# ---- Helper Functions ----
def get_overlapping_solid_tiles(rect_check, get_tile_func_arg):
    colliding_tile_info = []
    min_tx = max(0, int(rect_check.left // TILE_SIZE))
    max_tx = min(MAX_LEVEL_WIDTH_TILES - 1, int(rect_check.right // TILE_SIZE))
    min_ty = max(0, int(rect_check.top // TILE_SIZE))
    max_ty = min(LEVEL_HEIGHT_TILES - 1, int(rect_check.bottom // TILE_SIZE))

    for ty in range(min_ty, max_ty + 1):
        for tx in range(min_tx, max_tx + 1):
            tile_id = get_tile_func_arg(tx, ty)
            if tile_id in [1, 2, 3, 4, 5]:
                tile_rect = pygame.Rect(tx * TILE_SIZE, ty * TILE_SIZE, TILE_SIZE, TILE_SIZE)
                if rect_check.colliderect(tile_rect):
                    colliding_tile_info.append((tile_rect, tx, ty, tile_id))
    return colliding_tile_info

def update_camera():
    global camera_x
    target_camera_x = mario_player.x - WIDTH / 2.5
    camera_x += (target_camera_x - camera_x) * 0.08
    camera_x = max(0, min(camera_x, MAX_LEVEL_WIDTH_TILES * TILE_SIZE - WIDTH))

def draw_level():
    start_tx = int(camera_x // TILE_SIZE)
    end_tx = min(start_tx + int(WIDTH / TILE_SIZE) + 2, MAX_LEVEL_WIDTH_TILES)
    
    for ty in range(LEVEL_HEIGHT_TILES):
        for tx in range(start_tx, end_tx):
            tile_id = get_tile_type(tx, ty)
            if tile_id in TILE_COLORS:
                color = TILE_COLORS[tile_id]
                screen_x = (tx * TILE_SIZE - camera_x) * SCALE
                screen_y = ty * TILE_SIZE * SCALE
                pygame.draw.rect(screen, color, (screen_x, screen_y, TILE_SIZE * SCALE, TILE_SIZE * SCALE))

def mario_loses_life():
    global mario_player, score, camera_x, modified_tiles, enemies, active_powerups, last_enemy_spawn_x_segment
    print("Oh no! Mario fell or got hit! Resetting the level...")
    mario_player = Mario(50.0, (LEVEL_HEIGHT_TILES - 3) * TILE_SIZE)
    score = 0
    camera_x = 0
    modified_tiles.clear()
    enemies.clear()
    active_powerups.clear()
    last_enemy_spawn_x_segment = -1

# ---- Main Update Loop ----
def update_loop():
    global score, enemies, active_powerups

    mario_player.handle_input()
    mario_player.update_physics_and_collision(get_tile_type, modified_tiles, active_powerups, enemies)

    if mario_player.y > LEVEL_HEIGHT_TILES * TILE_SIZE:
        mario_loses_life()
        return True

    for item in active_powerups[:]:
        item.update(get_tile_type)
        if item.rect.colliderect(mario_player.rect):
            if item.item_type == ITEM_MUSHROOM:
                if mario_player.grow():
                    score += 1000
                active_powerups.remove(item)
        if item.y > HEIGHT * 2 or item.x < camera_x - WIDTH:
            active_powerups.remove(item)

    mario_body_rect = mario_player.rect
    mario_feet_rect = pygame.Rect(mario_player.x + 2, mario_player.y + mario_player.height - 4, mario_player.width - 4, 4)

    for enemy in enemies[:]:
        enemy.update()
        if mario_body_rect.colliderect(enemy.rect):
            is_stomping = (mario_player.vel_y > 0 and
                           mario_feet_rect.bottom >= enemy.rect.top and
                           mario_feet_rect.bottom <= enemy.rect.top + mario_player.vel_y + gravity + 2)
            if is_stomping:
                enemies.remove(enemy)
                score += 200
                mario_player.vel_y = mario_player.jump_strength * 0.6
                mario_player.on_ground = False
                print("Boing! Mario stomped a Goomba!")
            else:
                if mario_player.shrink_or_die():
                    mario_loses_life()
                    return True
                else:
                    enemies.remove(enemy)
    
    spawn_enemies_procedurally()
    enemies = [e for e in enemies if e.y < HEIGHT * 2 and e.x > camera_x - (WIDTH * 2)]

    if mario_player.x >= (MAX_LEVEL_WIDTH_TILES - 3) * TILE_SIZE:
        print(f"Yippee! Level Complete! Final Score: {score}! You're a superstar!")
        return False

    update_camera()

    screen.fill((107, 140, 255))  # Bright blue sky
    draw_level()
    for item in active_powerups:
        item.draw(camera_x)
    for enemy in enemies:
        enemy.draw(camera_x)
    mario_player.draw(camera_x)

    score_text = font.render(f"Score: {score}", True, WHITE)
    screen.blit(score_text, (10, 10))
    
    pygame.display.flip()
    return True

# ---- Main Async Game Loop ----
async def main():
    global mario_player, score, camera_x, modified_tiles, enemies, active_powerups, last_enemy_spawn_x_segment
    
    mario_player = Mario(50.0, (LEVEL_HEIGHT_TILES - 3) * TILE_SIZE)
    mario_player.y -= (mario_player.height - mario_player.base_height)
    
    score = 0
    camera_x = 0.0
    modified_tiles.clear()
    enemies.clear()
    active_powerups.clear()
    last_enemy_spawn_x_segment = -1

    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
        
        if not running:
            break

        running = update_loop()
        
        await asyncio.sleep(1.0 / FPS)

    pygame.quit()
    print("Thanks for playing in the Mushroom Kingdom! Come back for more adventures!")

# Run the game!
if __name__ == "__main__":
    if platform.system() == "Emscripten":
        asyncio.run(main())
    else:
        asyncio.run(main())
